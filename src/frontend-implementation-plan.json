{
  "kind": "implementation_plan",
  "version": "1.0",
  "title": "Username-based session unlock role for memory visibility and editing (tingi99 vs meow99)",
  "requirements": [
    {
      "id": "REQ-62",
      "summary": "Persist unlocked username in sessionStorage and expose it via password-gate state; clear on Lock.",
      "acceptanceCriteria": [
        "After a successful unlock, refreshing the page during the same browser session keeps the user unlocked AND retains which username was used to unlock.",
        "Clicking the existing \"Lock\" action re-locks the site and removes the stored unlocked flag and the stored unlocked username from sessionStorage.",
        "No new UI is added for configuring roles; the role is derived only from the username entered on the existing PasswordGate screen."
      ],
      "file_operations": [
        {
          "path": "frontend/src/hooks/usePasswordGate.ts",
          "operation": "modify",
          "description": "Extend the password-gate hook to persist the successfully-unlocked username (\"tingi99\" or \"meow99\") in sessionStorage alongside the existing unlocked flag; on initialization restore both values and treat the session as locked unless both are present/valid; on lock() clear both keys and reset in-memory state."
        },
        {
          "path": "frontend/src/App.tsx",
          "operation": "modify",
          "description": "Consume the extended password-gate state (including unlocked username) so the rest of the UI can branch on the active unlock role; ensure the existing Lock action continues to fully re-lock (including clearing stored unlocked username) while preserving existing welcome-gate behavior."
        }
      ]
    },
    {
      "id": "REQ-63",
      "summary": "Filter memories by unlock username for the Memories list and full-screen viewer only (tingi99: all, meow99: own Principal).",
      "acceptanceCriteria": [
        "When unlocked as \"tingi99\", the Memories count and list include all stored memories returned by the backend.",
        "When unlocked as \"meow99\", the Memories list renders only memories whose `memory.submitter` matches the current `identity.getPrincipal()` value.",
        "When unlocked as \"meow99\" and the visitor has no matching memories, show the existing empty-state layout but with user-facing text in English explaining that only their own memories are visible under meow99.",
        "The YouTube links feature and Music Box feature remain unchanged and still show shared lists as they do now (no username-based filtering is applied there)."
      ],
      "file_operations": [
        {
          "path": "frontend/src/App.tsx",
          "operation": "modify",
          "description": "Apply username-based filtering to the memories array used for the Memories count and MemoryList rendering: if unlocked as \"tingi99\" show all, if \"meow99\" filter to memories whose submitter matches the current Internet Identity principal from useInternetIdentity; keep MusicBoxWidget and YouTubeLinksDialog logic unchanged."
        },
        {
          "path": "frontend/src/components/MemoryList.tsx",
          "operation": "modify",
          "description": "Add an optional prop to customize the empty-state message (while keeping the existing empty-state layout) so App can supply an English explanation when unlocked as \"meow99\" and no matching memories are visible."
        },
        {
          "path": "frontend/src/components/MemoryFullscreenViewer.tsx",
          "operation": "modify",
          "description": "Accept the active unlock username and current principal (as strings) and enforce viewer visibility rules defensively: when unlocked as \"meow99\" and the memory submitter does not match the current principal, show a simple English access-restricted message within the viewer rather than rendering the memory content."
        },
        {
          "path": "frontend/src/components/MemoryList.tsx",
          "operation": "modify",
          "description": "Wire the role/principal props through from each memory card into MemoryFullscreenViewer so the full-screen viewer can apply the same meow99 visibility restriction."
        }
      ]
    },
    {
      "id": "REQ-64",
      "summary": "Enforce username-based editing UI rules within the memory editing experience (no backend changes).",
      "acceptanceCriteria": [
        "When unlocked as \"tingi99\", the current edit enable/disable behavior remains unchanged: edit is enabled only when `memory.submitter` matches the current Internet Identity principal.",
        "When unlocked as \"meow99\", edit controls are only available for memories that pass the meow99 visibility filter and match the current Internet Identity principal (no UI path allows editing any other memory).",
        "No changes are made to backend edit authorization logic; backend still rejects edits when the caller is not the original submitter."
      ],
      "file_operations": [
        {
          "path": "frontend/src/components/MemoryList.tsx",
          "operation": "modify",
          "description": "Update edit-control gating to incorporate the active unlock username and current principal: for \"tingi99\" preserve the existing submitter==principal rule; for \"meow99\" ensure edit is only possible when submitter==principal (and therefore also visible under the meow99 filter). Also pass role/principal into MemoryEditDialog wiring."
        },
        {
          "path": "frontend/src/components/MemoryFullscreenViewer.tsx",
          "operation": "modify",
          "description": "Update the viewer edit icon enable/disable logic to incorporate the active unlock username and current principal: keep the existing submitter==principal rule for \"tingi99\" and restrict \"meow99\" to only submitter==principal; ensure edit cannot be initiated from the viewer when the memory is not allowed under the current role."
        },
        {
          "path": "frontend/src/components/MemoryEditDialog.tsx",
          "operation": "modify",
          "description": "Add a defensive canEdit/role-aware guard prop so that if the dialog is ever opened without permission, it shows an English message and disables saving; keep all mutation behavior unchanged so the backend continues to enforce submitter-only edits."
        },
        {
          "path": "frontend/src/components/MemoryList.tsx",
          "operation": "modify",
          "description": "Wire the new MemoryEditDialog guard prop from the memory card edit button flow so the dialog behavior aligns with the role-based editing rules."
        },
        {
          "path": "frontend/src/components/MemoryFullscreenViewer.tsx",
          "operation": "modify",
          "description": "Wire the new MemoryEditDialog guard prop from the full-screen viewer edit button flow so the dialog behavior aligns with the role-based editing rules."
        }
      ]
    }
  ]
}